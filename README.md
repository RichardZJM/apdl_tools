# ANSYS APDL Solid185 Tool 

ANSYS is a commonly used FEM (finite element method) software often used for the engineering analysis of mechanical and structural components. Within ANSYS mechanical, APDL script can be used perform analyses. Although free meshing (automated) techniques are available, meshes are mostly restricted to tetrahedral elements which lack accuracy and computational efficiency when compared to hexahedral elements. One such hexahedral element is SOLID185 with which mapped meshing can be performed. A heavily manual process, users must sequentially define the

1. Keypoints
2. Lines
3. Areas
4. Volumes

which constitue the elements of the model of interest. Each stage is built off the definitions of the previous stages: a line is defined using two keypoints, an area is defined using four connected lines, and a volume is made from six area. Although all four stages are required, some information is redundant. Consider a square with four keypoints and lines between them. It is sufficient to describe this square using these two stages without explicitly naming the area. With reference to graph theory, we can recongnize that areas are simply cycles in the graph of keypoints (verticies) and lines (edges). Searching for these cycles can automate the production of area commands. A similar process was theorized for volume definition. Thus came the inspiration for this project.

## User Input Parsing
User inputs are parsed using Regex, specifically searching for line definitions. Lines are defined by referencing to keypoints, meaning the keypoint definitions are not required. Indeed the keypoint positions are irrelevant to solve cycles. Regex is used for this although it should be probably avoided in production code. The user inputs are then proccessed into a hash-map based implementation of a undirected graph.

## Area Searching
As alluded to previously, we can run a cycle finding algorithim to find all cycles of length four which would indicate the presence of an area. This project implements it as series of depth-limited depth first searches originating from each of the verticies. All four length paths which include the originating cycle are searched, and the path which return to the originating node area saved in a set. One thing to note is that the lines associated with each area must be returned in either clockwise or counterclockwise order. Sorting can be used to the find distinguish between in the two in set.  The subsequent verticies can ignore the previous verticies in each path as the all area associated with previous nodes are already determined. This is an O(n) approach.

##  Volume search
Volume searching is performed similarily to the area searching. The difference here is that the program must provide the six areas that compose it. The algorithim here approaches this problem by treat four of these areas as a loop and performing a depth limit DFS like before. However, an limitation is imposed on the third area such that is not adjacent to the originating area, and that the fourth area is not adjacent to the second area. Thus, for the cycle to be complete, it must be that the no area are adjacent to any area in the loop that are not it's immediate neighbours in the cycle. The four-area cycles can be inserted in a hashmap using the id of the third area as a key. This third area is conceptually the area opposite to the originating area in the volume. There are thus two cycles (not considering inverse cycles) which can have this third area as the opposite area. The set of these two different paths must contains all the areas present in the volume. It follows that when we inserted a four-area cycle whose id is already in the hashmap, we must be encountering either the cycle already stored in the hashamp, its inverse, or the corresponding cycle that makes up the volume. Sorting the cycles can be used to identify and ignore the first two cases, and in the third, we simply take the set of all area identities in the union of the two cycles and stored it in a master output set which contains all the volume found thus far. Since this process finds all volumes which contain the originating area, subsequent DFS operations can wholly ignore previously DFS'd areas. This is an O(n) approach.

